1.
类  对象的 介绍
如果你去中关村想买几台组装的PC机，到了那里你第一步要干什么， 是不是装机的工程师和你坐在一起，按你提供的信息和你一起完成一个装机的配置单呀， 这个配置单就可以想像成是类，它就是一张纸，但是它上面记录了你要买的PC机的信息，如果用这个配置单买10台机器，那么这10台机子，都是按这个配置单 组成的，所以说这10台机子是一个类型的，也可以说是一类的。那么什么是对象呢，类的实例化结果就是对象, 用这个配置单配置出来（实例化出来）的机子就是对象， 是我们可以操作的实体， 10台机子， 10个对象。 每台机子都是独立的，只能说明他们是同一类的，对其中一个机做任何动作都不会影响其它9台机器，但是我对类修改， 也就是在这个配置单上加一个或少一个配件， 那么装出来的9个机子都改变了， 这是类和对象的关系(类的实例化结果就是对象) 

2.
一个类可以生成多个对象  利用这个对象对成员属性做任何的修改  对象彼此之间是不受影响的 比如：
<?php
class Hushaoliang
{
    public $name;
    public $age;
    public function index()
    {
        print_r($this->name);
    }
}

$arr = new Hushaoliang();
$brr = new Hushaoliang();
$arr->name = 'hushaoliang';
$brr->name = "lijinjin";
print_r($arr->index());
print_r($brr->index());
?>

比如我们实例化了两个对象$arr 和 $brr  这是一个类生成的两个对象  我们可以利用这两个对象对成员属性赋值  然后利用自己本身的对象去读取 两者是相互不受任何的影响的！ 记住了 一个类可以生成多个对象 并且相互之间不受任何的影响！

3.
成员属性最好在声明的时候不要给初使的值！
构造方法是默认的公有方法（构造方法不要设置成私有的）
4.
如何实例化对象 存储到了什么位置 如何调用的  内存原理详细剖析：http://www.cnblogs.com/52php/p/5658049.html

5.
$this就是对象内部代表这个对象的引用

6.
对封装进一步的理解：
用个实例来说明吧， 假如某个人的对象中有年龄和工资等属性，像这样个人隐私的属性是不想让其它人随意就能获得到的，如果你不使用封装，那么别人想知道就能得到，但是如果你封装上之后别人就没有办法获得封装的属性， 除非你自己把它说出去，否则别人没有办法得到。
在比如说，个人电脑都有一个密码，不想让其它人随意的登陆，在你电脑里面拷贝和粘贴。还有就是像人这个对象， 身高和年龄的属性， 只能是自己来增涨，不可以让别人随意的赋值等等！

封装：
私有的成员只能在类的内部使用， 不能被类外部直接来存取， 但是在类的内部是有权限访问的， 所以有时候我们需要在类的外面给私有属性赋值和读取出来，也就是给类的外部提供一些可以存取的接口，上例中构造方法就是一种赋值的形式， 但是构造方法只是在创建对象的时候赋值，如果我们已经有一个存在的对象了，想对这个存在的对象赋值， 这个时候，如果你还使用构造方法传值的形式传值， 那么就创建了一个新的对象，并不是这个已存在的对象了。所以我们要对私有的属性做一些可以被外部存取的接口，目的就是可以在对象存在的情况下，改变和存取 属性的值，但要注意，只有需要让外部改变的属性才这样做，不想让外面访问的属性是不做这样的接口的，这样就能达到封装的目的，所有的功能都是对象自己来完 成，给外面提供尽量少的操作。

7.
__get（）方法
当访问私有成员属性的时候会自动访问这个__get() 我们可以在__get()方法当中返回想要的私有成员属性！
当访问不存在的成员属性的时候会自动访问这个__get（）方法  我们可以在这个__get()方法当中将错误写入日志或者返回一个别的实例化后的对象

__set（）方法
当设置私有成员属性的时候会自动访问这个__set() 我们可以在__set()方法当中返回想要的私有成员属性！
当设置不存在的成员属性的值时候会自动访问这个__set（）方法  我们可以在这个__set()方法当中将错误写入日志或者返回一个别的实例化后的对象

__isset(   )方法
如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用“isset()”函数来测定私有成员属性是否被设定了呢？可以，你只要在类里面加上一个“__isset()”方法就可以了，当在类外部使用”isset()”函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的“__isset()”方法了帮我们完成这样的操作
ege:
<?php
class Hushaoliang
{
    private $name =  'hushaoliang';
    private $age;

    function __isset($name)
    {
        echo "怎么可以这样嫩？";die;
    }
}
$arr = new Hushaoliang();
$a = isset($arr->name);
var_dump($a);
?>

__unset()方法：
如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性，如果对象的成员属性是私有的，我使用这个函数就没有权限去删除，但同样如果你在一个对象里面加上“__unset()”这个方法，就可以在对象的外部去删除对象的私有成员属性了

__set()， __get() 是专门为类的私有属性（private、protected）设立的 以及訪問和設置不存在的成员属性，对于类的公开（public）属性，外面是可以直接访问与设置的（如：$p1->name），即不走__set()，__get()函数的！！！

在PHP5.3及以后，上述魔术方法（__get(),__set(),__isset(),__unset() 等）提倡是 public 类型的，并且不是 static 方法，否则会给出警告信息！

8.
继承：
就是继承呗！
如果子类当中有和父类当中相同名称的方法 那么子类当中的会覆盖掉父类当中的方法 ！ 如果不想覆盖保留父类里面的功能的话 可以使用parent：：方法名称（）即可！

9.
访问类型：（这也可以归结为封装）
public 公有修饰符，类中的成员将没有访问限制，所有的外部成员都可以访问（读和写）这个类成员(包括成员属性和成员方法)，在PHP5之前的所有版本中，PHP 中类的成员都是public的，而且在PHP5中如果类的成员没有指定成员访问修饰符，将被视为public 

private 私有修改符，被定义为private的成员，对于同一个类里的所有成员是可见的，即没有访问限制；但对于该类的外部代码是不允许改变甚至读操作，对于该类的子类，也不能访问private修饰的成员

protected保护成员修饰符，被修饰为protected的成员不能被该类的外部代码访问。但是对于该类的子类有访问权限，可以进行属性、方法的读及写操作，该子类的外部代码包括其的子类都不具有访问其属性和方法的权限。



子类中方法的访问权限一定不能低于父类被覆盖方法的访问权限，也就是一定要高于或等于父类方法的访问权限。
例如，如果父类方法的访问权限是protected，那么子类中要覆盖的权限就要是protected和public，如果父类的方法是public那么子类中要覆盖的方法只能也是public，总之子类中的方法总是要高于或等于父类被覆盖方法的访问权限。

10.
final关键字
被final定义的类不能被继承
被final定义的方法不能是覆盖 是最终版本

11.
static关键字
static成员能够限制外部的访问，因为static的成员是属于类的，是不属于任何对象实例，是在类第一次被加载的时候分配的空间，其他类是无法访问的，只对类的实例共享，能一定程度对类该成员形成保护；从内存的角度我们来分析一下，内存从逻辑上被分为四段，其中对象是放在“堆内存”里面，对象的引用被放到了“栈内存“里，而静态成员则放到了“初始化静态段”，在类第一次被加载的时候放入的，可以让堆内存里面的每个对象所共享，如下图：

类的静态变量，非常类似全局变量，能够被所有类的实例共享，类的静态方法也是一样的，类似于全局函数。
静态成员被这个类的每个实例对象所共享
因为静态成员是在类第一次加载的时候就创建的，所以在类的外部不需要对象而使用类名就可以访问的到静态的成员；
静态的成员不是在每个对象内部存在的，但是每个对象都可以共享，所以我们如果使用对象访问成员的话就会出现没有这个属性定义，使用对象访问不到静态成员的，
类里面的静态方法只能访问类的静态的属性
在类里面的静态方法是不能访问类的非静态成员的，原因很简单，我们要想在本类的方法中访问本类的其它成员，我们需要使用$this这个引用，而$this这个引用指针是代表调用此方法的对象，我们说了静态的方法是不用对象调用的，而是使用类名来访问， 所以根本就没有对象存在，也就没有$this这个引用了，没有了$this这个引用就不能访问类里面的非静态成员，又因为类里面的静态成员是可以不用对象 来访问的，所以类里面的静态方法只能访问类的静态的属性，即然$this不存在，在静态方法中访其它静态成员我们使用的是一个特殊的类“self”; self和$this相似，只不过self是代表这个静态方法所在的类。

<?
class Person {
    // 下面是人的静态成员属性
    public static $myCountry = "中国";
 
    // 这是人的静态成员方法， 通过self访问其它静态成员
    public static function say() {
        echo "我是" . self::$myCountry;
    }
}

在非静态方法里可不可以访问静态成员呢，当然也是可以的了，但是也不能使用“$this”引用，也要使用类名或是”self::成员属性的形式”。

12.
const关键字
const是一个定义常量的关键字，在PHP中定义常量使用的是“define()”这个函数，但是在类里面定义常量使用的是“const”这个关键字，类似于C中的#define如果在程序中改变了它的值，那么会出现错误，用“const”修饰的成员属性的访问方式和“static”修饰的成员访问的方式差不多，也是使用“类名”，在方法里面使用“self”关键字。但是不用使用“$”符号，也不能使用对象来访问。
const   USERNAME = 'lijinjin';
访问形式 self::USERNAME;

13.
__toString()方法
“__toString()”方法也是一样自动被调用的，是在直接输出对象引用时自动调用的， 前面我们讲过对象引用是一个指针，比如 说：“$p=new Person()“中，$p就是一个引用，我们不能使用echo 直接输出$p，这样会输 出“Catchable fatal error: Object of class Person could not be converted to string”这样的错误，如果你在类里面定义了“__toString()”方法，在直接输出对象引用的时候，就不会产生错误，而是自动调用 了”__toString()”方法， 输出“__toString()”方法中返回的字符，所以“__toString()”方法一定要有个返回值（return 语句）

14.
clone() 克隆
有的时候我们需要在一个项目里面，使用两个或多个一样的对象，如果你使用“new”关键字重新创建对象的话，再赋值上相同的属性，这样做比较烦琐而且也容易出错，所以要根据一个对象完全克隆出一个一模一样的对象，是非常有必要的，而且克隆以后，两个对象互不干扰。

定义了一个特殊的方法名“__clone()”方法，是在对象克隆时自动调用的方法，用“__clone()”方法将建立一个与原对象拥有相同属 性和方法的对象，如果想在克隆后改变原对象的内容，需要在__clone()中重写原本的属性和方法，  “__clone()”方法可以没有参数，它自 动包含$this和$that两个指针，$this指向复本，而$that指向原本；
<?
class Person {
    // 下面是人的成员属性
    var $name;  // 人的名子
    var $sex;   // 人的性别
    var $age;   // 人的年龄
 
    // 定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值
    function __construct($name = "", $sex = "", $age = "") {
        $this->name = $name;
        $this->sex = $sex;
        $this->age = $age;
    }
 
    // 这个人可以说话的方法, 说出自己的属性
    function say() {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age . "<br>";
    }
 
    // 对象克隆时自动调用的方法, 如果想在克隆后改变原对象的内容，需要在__clone()中重写原本的属性和方法
    function __clone() {
        // $this指的复本p2, 而$that是指向原本p1，这样就在本方法里，改变了复本的属性。
        $this->name = "我是假的 $that->name";
        $this->age = 30;
    }
}
 
$p1 = new Person("张三", "男", 20);
$p2 = clone $p1;
$p1->say();
$p2->say();
?>

15.
__call() 当调用一个不存在的成员方法的时候会自动调用__call()方法 有两个参数 第一个参数是要调用的成员方法的名称 第二个参数是传递进来的值是一个数组形式
<?php
// 这是一个测试的类，里面没有属性和方法
class Test {
    // 调用不存的方法时自动调用的方法，第一个参数为方法名，第二个参数是数组参数
    function __call($function_name, $args) {
        print "你所调用的函数：$function_name(参数：";
        print_r($args);
        echo ")不存在！<br>";
    }
}
 
// 产生一个Test类的对象
$test = new Test();
 
// 调用对象里不存在的方法
$test->demo("one", "two", "three");
 
// 程序不会退出可以执行到这里
echo "this is a test<br>";
?>
上例输出结果为：
你所调用的函数： demo(参数：Array ( [0] => one [1] => two [2] => three ) )不存在！
this is a test

16.
抽象类和抽象方法：
什么是抽象方法？我们在类里面定义的没有方法体的方法就是抽象方法，所谓的没有方法体指的是，在方法声明的时候没有大括号以及其中的内容，而是直接在声明时在方法名后加上分号结束，另外在声明抽象方法时还要加一个关键字“abstract”来修饰；
那么什么是抽象类呢？只要一个类里面有一个方法是抽象方法，那么这个类就要定义为抽象类，抽象类也要使用“abstract”关键字来修饰；在抽象类里面可以有不是抽象的方法和成员属性，但只要有一个方法是抽象的方法，这个类就必须声明为抽象类，使用”abstract”来修饰。
抽象类不能被实例化  并且继承了抽象类的子类必须实现抽象类里面的方法；
子类必须把父类中的抽象方法全部都实现，否则子类中还存在抽象方法，那么子类还是抽象类，还是不能实例化类

抽象类主要是用来作为规范的  规定必须要实现的有哪些方法！

17.
接口：
PHP引入了接口，接口的思想是指定了一个实现了该接口的类必须实现的一系列方法
接口是一种特殊的抽象类，抽象类又是一种特殊的类，所以接口也是一种特殊的类
为 什么说接口是一种特殊的抽象类呢？如果一个抽象类里面的所有的方法都是抽象方法，那么我们就换一种声明方法使用“接口”；也就是说接口里面所有的方法必须 都是声明为抽象方法，另外接口里面不能声明变量(但可声明常量constant)，而且接口里面所有的成员都是public权限的。所以子类在实现的时候 也一定要使用public权限实限。

声明一个类的时候我们使用的关键字是“class”，而接口一种特殊的类，使用的关键字是“interface”;

接口里面所有的方法都是抽象方法，所以在声明抽象方法的时候就不用像抽象类那样使用“abstract”这个关键字了，默认的已经加上这个关键字，另外在接口里边的”public”这个访问权限也可以去掉，因 为默认就是public的，因为接口里所有成员都要是公有的，所在对于接口里面的成员我们就不能使用“private”的和“protected”的权限 了，都要用public或是默认的。另外在接口里面我们也声明了一个常量“constant“， 因为在接口里面不能用变量成员，所以我们要使用 const这个关键字声明

我们定义一接口的子类去实现接口中全部抽象方法使用的关键字是“implements”，而不是我们前面所说的“extends”;
<?php
// 使用“implements”这个关键字去实现接口中的抽象方法 接口和类之间
class Three implements One {
    function fun1() {
        ...
    }
 
    function fun2() {
        ...
    }
}

在前面我们说过，PHP是单继承的，一个类只能有一父类，但是一个类可以实现多个接口，就相当于一个类要遵守多个规范，就像我们不仅要遵守国家的法律，如果是在学校的话，还要遵守学校的校规一样；
<?php
// 使用implements实现多个接口
class Four implements 接口一, 接口二, ... {
    // 必须把所有接口中的方法都要实现才可以实例化对象。
}
?>

PHP中不仅一个类可以实现多个接口，也可以在继承一个类的同时实现多个接口, 一定要先继承类再去实现接口；
<?php
// 使用extends继承一个类，使用implements实现多个接口
class Four extends 类名一 implements 接口一, 接口二, ... {
    // 所有接口中的方法都要实现才可以实例化对象
    ...
}
?>

我们可以使用”extends”关键字让一个接口去继承另一个接口：

18.
多态的理解：
比如说在公司上班，每个月财务发放工资，同一个发工资的方法，在公司内不同的员工或是不同职位的员工，都是通过这个方法发放的，但是所发的工资都是不相同的。所以同一个发工资的方法就出现了多种形态

再比如我们写了一个接口 里面有两个抽象方法 一个是求周长的 一个是求面积的 现在我们写一个类来实现这个接口 然后实例化这个类  然后调取里面的求周长和面积的方法那么得出的是一个答案
然后我们再写一个类来实现接口 然后实例化此类 然后传入不同的参数 调取里面的方法 那么得到的又是另外的答案

同样的方法得到的却是不同的结果  这就是多态！

19.
对象的串行化：
有时候需要把一个对象在网络上传输，为了方便传输，可以把整个对象转化为二进制串，等到达另一端时，再还原为原来的对象，这个过程称之为串行化(也叫序列化)
有两种情况我们必须把对象串行化，第一种情况就是把一个对象在网络中传输的时候要将对象串行化，第二种情况就是把对象写入文件或是数据库的时候用到串行化。

串行化有两个过程，一个是串行化，就是把对象转化为二进制的字符串，我们使用serialize()函数来串行化一个对象，另一个是反串行化，就是把对象转化的二进制字符串再转化为对象， 我们使用unserialize()函数来反串行化一个对象。

<?
class Person {
    // 下面是人的成员属性
    var $name;  // 人的名子
    var $sex;   // 人的性别
    var $age;   // 人的年龄
 
    // 定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值
    function __construct($name = "", $sex = "", $age = "") {
        $this->name = $name;
        $this->sex = $sex;
        $this->age = $age;
    }
 
    // 这个人可以说话的方法, 说出自己的属性
    function say() {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age . "<br>";
    }
}
 
$p1 = new Person("张三", "男", 20);
$p1_string = serialize($p1);    // 把一个对象串行化，返一个字符串
echo $p1_string . "<br>";     // 串行化的字符串我们通常不去解析
$p2 = unserialize($p1_string);  // 把一个串行化的字符串反串行化形成对象$p2
$p2->say();
?>

在PHP5中有两个魔术方法__sleep()方法和__wakeup()方法，在对象串行化的时候，会调用一个__sleep()方法来完成一 些睡前的事情；而在重新醒来，即由二进制串重新组成一个对象的时候，则会自动调用PHP的另一个函数__wakeup()，做一些对象醒来就要做的动作。
__sleep()函数不接受任何参数， 但返回一个数组，其中包含需要串行化的属性。末被包含的属性将在串行化时被忽略，如果没有__sleep()方法，PHP将保存所有属性。

<?
class Person {
    // 下面是人的成员属性
    var $name;  // 人的名子
    var $sex;   // 人的性别
    var $age;   // 人的年龄
 
    // 定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值
    function __construct($name = "", $sex = "", $age = "") {
        $this->name = $name;
        $this->sex = $sex;
        $this->age = $age;
    }
 
    // 这个人可以说话的方法, 说出自己的属性
    function say() {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age . "<br>";
    }
 
    // 指定串行化时把返回的数组中$name和$age值串行化，忽略没在数组中的属性$sex
    function __sleep() {
        $arr = array("name", "age"); // 此时，属性$sex将被删除！！！
        return($arr);
    }
 
    // 重新生成对象时，并重新赋值$age为40
    function __wakeup() {
        $this->age = 40;
    }
}
 
$p1 = new Person("张三", "男", 20);
 
// 把一个对象串行化，返一个字符串，调用了__sleep()方法,忽略没在数组中的属性$sex
$p1_string = serialize($p1);
echo $p1_string . "<br>"; // 串行化的字符串我们通常不去解析
 
$p2 = unserialize($p1_string); // 反串行化形成对象$p2重新赋值$age为40
$p2->say();
?>

20.
自动加载
以定义一个 __autoload()函数，它会在试图使用尚未被定义的类时自动调 用，通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类， __autoload()函数接收的一个参数，就是你想加载的类的 类名
<?php
function __autoload($classname) {
    require_once $classname . '.php';
}
 
// MyClass1类不存在时，自动调用__autoload()函数，传入参数”MyClass1”
$obj = new MyClass1();
 
// MyClass2类不存在时，自动调用__autoload()函数，传入参数”MyClass2”
$obj2 = new MyClass2();
?>
